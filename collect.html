<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>city_state_collect.html — All Cities & States (Category crawl)</title>
<style>
  :root{
    --bg:#071026; --muted:#9aa4b2; --accent:#60a5fa; --glass: rgba(255,255,255,0.03);
    --ok:#16a34a; --warn:#f59e0b; --err:#ef4444;
  }
  html,body{height:100%;margin:0;font-family:Inter,Segoe UI,Roboto,Arial,sans-serif;background:linear-gradient(180deg,#041127 0%,#071024 100%);color:#e6eef6}
  .wrap{max-width:1100px;margin:20px auto;padding:18px}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{margin:0;font-size:1.2rem}
  p.lead{margin:6px 0 14px;color:var(--muted);max-width:760px}
  .controls{display:flex;gap:8px;align-items:center}
  button{background:var(--accent);border:none;padding:8px 12px;border-radius:8px;color:#06202b;font-weight:700;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:var(--accent)}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:10px;border:1px solid rgba(255,255,255,0.03);margin-top:12px}
  .meta{font-size:0.85rem;color:var(--muted)}
  .result-list{margin:10px 0 0;padding:8px;background:var(--glass);border-radius:8px;max-height:360px;overflow:auto;font-family:ui-monospace,monospace;font-size:0.95rem;white-space:pre-wrap}
  .progressbar{height:10px;background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden;margin-top:12px}
  .progress{height:100%;background:linear-gradient(90deg,var(--accent),rgba(96,165,250,0.6));width:0%}
  .small{font-size:0.85rem;color:var(--muted)}
  .status{display:inline-block;padding:6px 8px;border-radius:999px;font-weight:700}
  .status.ok{background:rgba(22,163,74,0.08);color:var(--ok)}
  .status.warn{background:rgba(245,158,11,0.08);color:var(--warn)}
  .status.err{background:rgba(239,68,68,0.08);color:var(--err)}
  .copybtn{margin-left:8px;padding:6px 9px;border-radius:8px;background:transparent;color:var(--accent);border:1px solid rgba(255,255,255,0.03);cursor:pointer}
  pre.copybox{white-space:pre-wrap;background:#021124;padding:10px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);font-family:ui-monospace,monospace;font-size:0.9rem;max-height:360px;overflow:auto}
  label{display:inline-flex;gap:8px;align-items:center;color:var(--muted);font-size:0.9rem}
  input[type="number"]{width:80px;padding:6px;border-radius:6px;border:none;background:rgba(255,255,255,0.02);color:var(--muted)}
  @media(min-width:860px){ .grid{display:grid;grid-template-columns:repeat(2,1fr);gap:12px} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <div>
      <h1>city_state_collect.html — Crawl All Cities & States</h1>
      <p class="lead">Crawls Wikipedia categories to collect <strong>all</strong> states (ADM1) and cities (populated places) for five countries. For each place it fetches the Wikipedia extract and Wikidata claims (population, area, coordinates, image). Results are copyable/downloadable as JSON.</p>
    </div>
    <div class="controls">
      <label>Throttle ms:
        <input id="throttle" type="number" min="100" max="2000" value="400"/>
      </label>
      <label>Concurrency:
        <input id="concurrency" type="number" min="1" max="8" value="3"/>
      </label>
      <button id="startBtn">Start Fetch</button>
      <button id="copyAllBtn" class="ghost">Copy All JSON</button>
      <button id="downloadBtn" class="ghost">Download JSON</button>
    </div>
  </header>

  <div class="card" style="margin-top:12px">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div><strong>Progress</strong> <span class="small" id="progressText">Idle</span></div>
      <div><span id="stats" class="small">0 / 0</span></div>
    </div>
    <div class="progressbar"><div id="progress" class="progress"></div></div>
  </div>

  <div id="results" class="grid"></div>

  <div style="margin-top:14px;color:var(--muted);font-size:0.9rem">
    Note: This will do many requests. Results are cached in <code>localStorage</code> (prefix <code>csc:</code>). Clear storage to force fresh fetches.
  </div>
</div>

<script>
/*
  city_state_collect.html
  Browser-only crawler that:
   - Finds category pages for "cities" and "states" patterns for each country
   - Uses categorymembers API with continuation (cmlimit=max + cmcontinue) to get all members
   - For each member (page) fetches pageprops (to get Wikidata QID) and extracts, then fetches Wikidata entity JSON to collect claims
   - Caches responses in localStorage with prefix csc:
   - Provides UI for copying/downloading JSON
*/

// --- Config / Countries ---
const COUNTRIES = ["Switzerland","Syria","Tajikistan","Tanzania","Thailand","Timor-Leste","Togo","Tonga","Trinidad and Tobago","Tunisia","Turkey","Turkmenistan","Tuvalu","Uganda","Ukraine","United Arab Emirates","United Kingdom","United States"];
const WIKIPEDIA_API = "https://en.wikipedia.org/w/api.php?origin=*";
const WIKIDATA_ENTITY = 'https://www.wikidata.org/wiki/Special:EntityData';
const CACHE_PREFIX = 'csc:'; // city_state_collect

// category name patterns to try (cities)
const CITY_CATEGORY_TEMPLATES = [
  "Category:Cities in {country}",
  "Category:Populated places in {country}",
  "Category:Municipalities of {country}",
  "Category:Towns in {country}",
  "Category:Villages in {country}",
  "Category:Settlements in {country}",
  "Category:Populated places in the {country}" // fallback
];

// category name patterns to try (ADM1 / first-level subdivisions)
const ADM1_CATEGORY_TEMPLATES = [
  "Category:Provinces of {country}",
  "Category:States of {country}",
  "Category:Regions of {country}",
  "Category:Departments of {country}",
  "Category:Governorates of {country}",
  "Category:Administrative divisions of {country}",
  "Category:First-level administrative country subdivisions of {country}",
  "Category:Districts of {country}"
];

// UI refs
const startBtn = document.getElementById('startBtn');
const resultsEl = document.getElementById('results');
const progressEl = document.getElementById('progress');
const progressText = document.getElementById('progressText');
const statsEl = document.getElementById('stats');
const copyAllBtn = document.getElementById('copyAllBtn');
const downloadBtn = document.getElementById('downloadBtn');
const throttleInput = document.getElementById('throttle');
const concurrencyInput = document.getElementById('concurrency');

// runtime settings
let THROTTLE_MS = Number(throttleInput.value) || 400;
let CONCURRENCY = Math.max(1, Math.min(8, Number(concurrencyInput.value) || 3));

// small helpers
const sleep = ms => new Promise(r => setTimeout(r, ms));
const idFrom = s => (s||'').replace(/[^a-z0-9]/gi,'_');
const esc = s => (s+'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));

// localStorage cache helpers
function cacheKey(k){ return CACHE_PREFIX + k; }
function cacheGet(k){ try{ const j=localStorage.getItem(cacheKey(k)); return j?JSON.parse(j):null;}catch(e){return null;} }
function cacheSet(k,v){ try{ localStorage.setItem(cacheKey(k), JSON.stringify(v)); }catch(e){} }
function cacheRemove(k){ try{ localStorage.removeItem(cacheKey(k)); }catch(e){} }

// fetch with retry/backoff & Retry-After support
async function fetchWithRetry(url, opts = {}, maxRetries = 6, baseDelay = 700) {
  for (let attempt=0; attempt<=maxRetries; attempt++){
    try {
      const resp = await fetch(url, opts);
      if (resp.status === 429) {
        const ra = resp.headers.get('retry-after');
        const wait = ra ? (isNaN(Number(ra)) ? 5000 : Number(ra)*1000) : baseDelay*(attempt+1);
        console.warn('Rate limited 429; waiting', wait, 'ms');
        await sleep(wait);
        continue;
      }
      if (!resp.ok) {
        if (resp.status >= 500 && attempt < maxRetries) {
          const wait = baseDelay * Math.pow(2, attempt) + Math.random()*200;
          console.warn('Server', resp.status, '— retry in', Math.round(wait), 'ms');
          await sleep(wait);
          continue;
        }
        throw new Error('HTTP ' + resp.status + ' ' + resp.statusText + ' for ' + url);
      }
      return resp;
    } catch (err) {
      if (attempt === maxRetries) throw err;
      const wait = baseDelay * Math.pow(2, attempt) + Math.random()*200;
      console.warn('Fetch error; retry in', Math.round(wait), 'ms —', err && err.message ? err.message : err);
      await sleep(wait);
    }
  }
  throw new Error('fetchWithRetry exhausted for ' + url);
}

// --------------- Wikipedia category discovery & crawl ---------------

// Check whether a category exists (by calling query for the category page)
async function categoryExists(categoryTitle) {
  // Query pages for the category title
  const params = new URLSearchParams({
    action: 'query',
    titles: categoryTitle,
    format: 'json'
  });
  const url = `${WIKIPEDIA_API}&${params.toString()}`;
  const resp = await fetchWithRetry(url, {}, 3, 600);
  const data = await resp.json();
  // If page exists and not missing
  const pages = data.query && data.query.pages ? data.query.pages : {};
  const pid = Object.keys(pages)[0];
  if (!pid) return false;
  const p = pages[pid];
  if (!p) return false;
  return !p.missing;
}

// Find an existing category from a list of templates
async function pickCategory(country, templates) {
  for (const tmpl of templates) {
    const title = tmpl.replace('{country}', country);
    // Many category titles use the country's short name variant (e.g., "United Kingdom" vs "United Kingdom of Great Britain and Northern Ireland")
    // We try title as-is, and also replace spaces with underscores
    const normalized = title;
    if (cacheGet(`cat_exists:${normalized}`) !== null) {
      const exists = cacheGet(`cat_exists:${normalized}`);
      if (exists) return normalized;
      continue;
    }
    try {
      const exists = await categoryExists(normalized);
      cacheSet(`cat_exists:${normalized}`, exists);
      if (exists) return normalized;
    } catch (e) {
      // continue trying other templates
    }
    // also try a version with country words reversed? skip for simplicity
  }
  return null;
}

// Crawl all members of a category using continuation (cmlimit=max)
async function crawlCategoryMembersAll(categoryTitle) {
  const cacheKeyName = `cat_members:${categoryTitle}`;
  const cached = cacheGet(cacheKeyName);
  if (cached) return cached;

  const allMembers = [];
  let cmcontinue = null;
  while (true) {
    const params = new URLSearchParams({
      action: 'query',
      list: 'categorymembers',
      cmtitle: categoryTitle,
      cmlimit: 'max',
      format: 'json'
    });
    if (cmcontinue) params.set('cmcontinue', cmcontinue);
    const url = `${WIKIPEDIA_API}&${params.toString()}`;
    const resp = await fetchWithRetry(url, {}, 6, 700);
    const data = await resp.json();
    const members = data.query && data.query.categorymembers ? data.query.categorymembers : [];
    allMembers.push(...members);
    if (data.continue && data.continue.cmcontinue) {
      cmcontinue = data.continue.cmcontinue;
      // polite pause
      await sleep(250);
      continue;
    } else break;
  }
  cacheSet(cacheKeyName, allMembers);
  return allMembers;
}

// Fetch page props (to get wikibase_item) and plaintext extract for a batch of pages
async function fetchPagesDetails(titlesArray) {
  // titlesArray is an array of page titles (up to 50 per request)
  const joined = titlesArray.join('|');
  const params = new URLSearchParams({
    action: 'query',
    prop: 'pageprops|extracts',
    pageprops: 'wikibase_item',
    explaintext: '1',
    redirects: '1',
    titles: joined,
    format: 'json',
    exlimit: 'max'
  });
  const url = `${WIKIPEDIA_API}&${params.toString()}`;
  const resp = await fetchWithRetry(url, {}, 6, 700);
  const data = await resp.json();
  const pages = data.query && data.query.pages ? data.query.pages : {};
  // Return array of { title, pageid, wikibase_item, extract }
  const out = [];
  for (const pid of Object.keys(pages)) {
    const p = pages[pid];
    if (!p) continue;
    out.push({
      pageid: p.pageid || null,
      title: p.title || null,
      wikibase_item: p.pageprops && p.pageprops.wikibase_item ? p.pageprops.wikibase_item : null,
      extract: p.extract || ''
    });
  }
  return out;
}

// --------------- Wikidata entity helpers ---------------

// Fetch full entity JSON from Wikidata
async function fetchWikidataEntity(qid) {
  if (!qid) return null;
  const ck = cacheGet(`ent:${qid}`);
  if (ck) return ck;
  const url = `${WIKIDATA_ENTITY}/${qid}.json`;
  const resp = await fetchWithRetry(url, {}, 5, 700);
  const data = await resp.json();
  cacheSet(`ent:${qid}`, data);
  return data;
}

// Helper: extract common claims from entity JSON
function extractClaimsFromEntity(entityJson, qid) {
  try {
    const ent = entityJson.entities && entityJson.entities[qid];
    if (!ent) return {};
    const claims = ent.claims || {};
    function getFirstValue(pid) {
      const arr = claims[pid];
      if (!Array.isArray(arr) || !arr.length) return null;
      const mainsnak = arr[0].mainsnak;
      if (!mainsnak) return null;
      // value can be an object depending on type
      const val = mainsnak.datavalue && mainsnak.datavalue.value ? mainsnak.datavalue.value : null;
      return val;
    }
    // Population P1082 (may have qualifiers/date): return numeric amount if available
    let population = null;
    const popVal = getFirstValue('P1082');
    if (popVal) {
      if (typeof popVal === 'object') {
        if (popVal.amount) population = Number(popVal.amount);
        else if (popVal['time']) population = popVal['time'];
      } else if (!isNaN(Number(popVal))) population = Number(popVal);
    }
    // Area P2046
    let area = null;
    const areaVal = getFirstValue('P2046');
    if (areaVal) {
      if (areaVal.amount) area = Number(areaVal.amount);
      else if (!isNaN(Number(areaVal))) area = Number(areaVal);
    }
    // Coordinates P625
    let coord = null;
    const coordVal = getFirstValue('P625');
    if (coordVal && coordVal.latitude && coordVal.longitude) coord = { lat: coordVal.latitude, lon: coordVal.longitude };
    // Image P18 -> filename; build URL via special image info not necessary here
    let image = null;
    const imgVal = getFirstValue('P18');
    if (typeof imgVal === 'string') image = imgVal;
    // Return
    return { population, area, coord, image };
  } catch (e) {
    return {};
  }
}

// --------------- High-level flow per country ---------------

async function collectForCountry(country) {
  const cacheName = `country_result:${country}`;
  const cached = cacheGet(cacheName);
  if (cached) return cached;

  // 1) Discover categories for cities and ADM1
  const cityCategory = await pickFirstExistingCategory(country, CITY_CATEGORY_TEMPLATES);
  const admCategory = await pickFirstExistingCategory(country, ADM1_CATEGORY_TEMPLATES);

  const result = { country, cityCategory, admCategory, cities: [], states: [] };

  // 2) Crawl members (if category found)
  if (admCategory) {
    try {
      const admMembers = await crawlCategoryMembersAll(admCategory);
      // Filter to pages only (namespace 0)
      const admPages = admMembers.filter(m => m.ns === 0);
      // Batch titles to fetch pageprops+extract
      const admDetails = await fetchAllPagesBatched(admPages.map(p=>p.title));
      // Enrich with wikidata entity claims
      const admEnriched = await enrichWithWikidata(admDetails);
      result.states = admEnriched;
    } catch (e) {
      result.statesError = String(e);
    }
  } else {
    result.statesError = 'No ADM1 category found by templates';
  }

  if (cityCategory) {
    try {
      const cityMembers = await crawlCategoryMembersAll(cityCategory);
      const cityPages = cityMembers.filter(m => m.ns === 0);
      // fetch details
      const cityDetails = await fetchAllPagesBatched(cityPages.map(p=>p.title));
      const cityEnriched = await enrichWithWikidata(cityDetails);
      result.cities = cityEnriched;
    } catch (e) {
      result.citiesError = String(e);
    }
  } else {
    result.citiesError = 'No city category found by templates';
  }

  cacheSet(cacheName, result);
  return result;
}

// Try templates and return first category that exists (with some normalization)
async function pickFirstExistingCategory(country, templates) {
  for (const tmpl of templates) {
    const title = tmpl.replace('{country}', country);
    // Try exact
    try {
      if (await categoryExists(title)) return title;
    } catch(e){}
    // try alternative: replace spaces with underscores
    const alt = title.replace(/ /g,'_');
    try {
      if (await categoryExists(alt)) return alt;
    } catch(e){}
  }
  // last attempt: try "Category:Populated places in <Country>" with no punctuation changes
  return null;
}

// Fetch all page details by batching (titles per request up to 50)
async function fetchAllPagesBatched(titles) {
  const batchSize = 40; // keep safe under 50
  const out = [];
  for (let i=0;i<titles.length;i+=batchSize) {
    const batch = titles.slice(i, i+batchSize);
    try {
      const details = await fetchPagesDetails(batch);
      out.push(...details);
      // throttle
      await sleep(THROTTLE_MS);
    } catch (e) {
      // on error, push minimal entries
      for (const t of batch) out.push({ title: t, pageid: null, wikibase_item: null, extract: '' });
    }
  }
  return out;
}

// Enrich pages (page props + extract already present) with Wikidata claims
async function enrichWithWikidata(pageDetails) {
  // Build list of unique QIDs
  const items = pageDetails.map(d => ({
    title: d.title,
    pageid: d.pageid,
    qid: d.wikibase_item,
    extract: d.extract || ''
  }));

  // For items with qid, fetch entities in concurrent workers
  const toFetch = items.filter(it => it.qid);
  const qidList = Array.from(new Set(toFetch.map(it => it.qid)));

  // concurrent worker function to fetch wikidata entities
  const enrichedMap = {};
  let idx = 0;
  async function worker() {
    while (true) {
      const i = idx++;
      if (i >= qidList.length) return;
      const qid = qidList[i];
      try {
        const ent = await fetchWikidataEntity(qid);
        const claims = extractClaimsFromEntity(ent, qid);
        enrichedMap[qid] = { qid, claims };
        await sleep(THROTTLE_MS);
      } catch (e) {
        enrichedMap[qid] = { qid, claims: {}, error: String(e) };
      }
    }
  }
  const workers = [];
  const concurrency = Math.max(1, Math.min(CONCURRENCY, qidList.length || 1));
  for (let w=0; w<concurrency; w++) workers.push(worker());
  await Promise.all(workers);

  // build final enriched items array
  const final = items.map(it => {
    const qinfo = it.qid ? enrichedMap[it.qid] || { qid: it.qid, claims: {} } : null;
    return {
      title: it.title,
      pageid: it.pageid,
      qid: it.qid || null,
      extract: it.extract || '',
      population: qinfo && qinfo.claims ? qinfo.claims.population || null : null,
      area: qinfo && qinfo.claims ? qinfo.claims.area || null : null,
      coordinates: qinfo && qinfo.claims ? qinfo.claims.coord || null : null,
      image: qinfo && qinfo.claims ? qinfo.claims.image || null : null,
      wikidata_error: qinfo && qinfo.error ? qinfo.error : null
    };
  });

  return final;
}

// --------------- UI wiring ---------------

startBtn.addEventListener('click', async () => {
  try {
    THROTTLE_MS = Math.max(50, Number(throttleInput.value) || 400);
    CONCURRENCY = Math.max(1, Math.min(8, Number(concurrencyInput.value) || 3));
    resultsEl.innerHTML = '';
    resultsData = [];
    let completed = 0;
    progressText.textContent = 'Starting...';
    statsEl.textContent = `0 / ${COUNTRIES.length}`;
    progressEl.style.width = '0%';
    startBtn.disabled = true;

    for (let i=0;i<COUNTRIES.length;i++) {
      const country = COUNTRIES[i];
      updateProgress(i, COUNTRIES.length);
      const card = createCountryCard(country);
      resultsEl.appendChild(card);

      try {
        const res = await collectForCountry(country);
        resultsData.push(res);
        populateCard(card, res);
      } catch (e) {
        console.error('Country collect error', country, e);
        const res = { country, error: String(e), cities: [], states: [] };
        resultsData.push(res);
        populateCard(card, res);
      }

      completed++;
      statsEl.textContent = `${completed} / ${COUNTRIES.length}`;
      // polite pause between countries
      await sleep(800);
    }

    progressText.textContent = 'Completed';
    progressEl.style.width = '100%';
    startBtn.disabled = false;
  } catch (err) {
    console.error('Run error', err);
    alert('Error: ' + (err.message || err));
    startBtn.disabled = false;
  }
});

function createCountryCard(country) {
  const el = document.createElement('div');
  el.className = 'card';
  el.innerHTML = `
    <h3>${esc(country)} <span class="status" id="status-${idFrom(country)}">queued</span></h3>
    <div class="meta small">City category: <span id="catc-${idFrom(country)}">—</span> | State category: <span id="catd-${idFrom(country)}">—</span></div>
    <div id="list-${idFrom(country)}" class="result-list small">Waiting...</div>
    <div style="margin-top:8px;display:flex;gap:8px;align-items:center">
      <button class="copybtn" id="copy-${idFrom(country)}">Copy JSON</button>
      <button class="copybtn" id="download-${idFrom(country)}">Download</button>
    </div>
  `;
  return el;
}

function populateCard(cardEl, res) {
  const id = idFrom(res.country);
  const statusEl = cardEl.querySelector(`#status-${id}`);
  const catCityEl = cardEl.querySelector(`#catc-${id}`);
  const catAdmEl = cardEl.querySelector(`#catd-${id}`);
  const listEl = cardEl.querySelector(`#list-${id}`);
  const copyBtn = cardEl.querySelector(`#copy-${id}`);
  const downloadBtn = cardEl.querySelector(`#download-${id}`);

  catCityEl.textContent = res.cityCategory || '—';
  catAdmEl.textContent = res.admCategory || '—';

  if (res.error) {
    statusEl.textContent = 'error';
    statusEl.className = 'status err';
    listEl.innerHTML = `<div class="line">Error: ${esc(res.error)}</div>`;
    copyBtn.disabled = true;
    downloadBtn.disabled = true;
    return;
  }

  statusEl.textContent = 'ok';
  statusEl.className = 'status ok';

  const out = {
    country: res.country,
    cityCategory: res.cityCategory || null,
    admCategory: res.admCategory || null,
    cities: res.cities || [],
    states: res.states || [],
    citiesError: res.citiesError || null,
    statesError: res.statesError || null
  };

  const pretty = JSON.stringify(out, null, 2);
  listEl.innerHTML = `<pre class="copybox">${esc(pretty)}</pre>`;

  copyBtn.onclick = async ()=>{ await copyToClipboard(pretty); copyBtn.textContent='Copied ✓'; setTimeout(()=>copyBtn.textContent='Copy JSON',900); };
  downloadBtn.onclick = ()=>{ const blob = new Blob([pretty], {type:'application/json'}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = `${res.country.replace(/\s+/g,'_')}_places.json`; a.click(); URL.revokeObjectURL(url); };
}

// update progress bar
function updateProgress(i, total) {
  const pct = Math.round((i/total)*100);
  progressEl.style.width = pct + '%';
  progressText.textContent = `${i} / ${total} started`;
}

// copy all / download all
copyAllBtn.addEventListener('click', async () => {
  const full = JSON.stringify(resultsData, null, 2);
  await copyToClipboard(full);
  alert('All results copied to clipboard.');
});
downloadBtn.addEventListener('click', () => {
  const blob = new Blob([JSON.stringify(resultsData, null, 2)], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'all_places.json'; a.click(); URL.revokeObjectURL(url);
});

// pageprops + extract fetch (single title or batch via fetchAllPagesBatched)
async function fetchPagesDetails(titlesArray) {
  // batch up to 40 titles per request
  const batchSize = 40;
  const results = [];
  for (let i=0;i<titlesArray.length;i+=batchSize) {
    const batch = titlesArray.slice(i, i+batchSize);
    const joined = batch.join('|');
    const params = new URLSearchParams({
      action: 'query',
      prop: 'pageprops|extracts',
      pageprops: 'wikibase_item',
      explaintext: '1',
      redirects: '1',
      titles: joined,
      exlimit: 'max',
      format: 'json'
    });
    const url = `${WIKIPEDIA_API}&${params.toString()}`;
    try {
      const resp = await fetchWithRetry(url, {}, 6, 700);
      const data = await resp.json();
      const pages = data.query && data.query.pages ? data.query.pages : {};
      for (const pid of Object.keys(pages)) {
        const p = pages[pid];
        results.push({
          pageid: p.pageid || null,
          title: p.title || null,
          wikibase_item: p.pageprops && p.pageprops.wikibase_item ? p.pageprops.wikibase_item : null,
          extract: p.extract || ''
        });
      }
    } catch (err) {
      // on error, still create minimal placeholders for each title in batch
      for (const t of batch) results.push({ pageid: null, title: t, wikibase_item: null, extract: '' });
    }
    await sleep(THROTTLE_MS);
  }
  return results;
}

// Wrapper fetchPagesDetails for use elsewhere (keeps compatibility)
async function fetchAllPagesBatched(titles) {
  return await fetchPagesDetails(titles);
}

</script>
</body>
</html>
