<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Monarch Biographies Collector — 5 Countries (Fixed)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial;margin:0;background:#071024;color:#e6eef6}
  .wrap{max-width:1100px;margin:20px auto;padding:18px}
  header{display:flex;justify-content:space-between;align-items:center;gap:12px}
  h1{margin:0;font-size:1.2rem}
  .lead{color:#9aa4b2;max-width:760px}
  .controls{display:flex;gap:8px}
  button{background:#60a5fa;border:none;padding:8px 12px;border-radius:8px;color:#022;cursor:pointer}
  button.ghost{background:transparent;border:1px solid rgba(255,255,255,0.06);color:#60a5fa}
  .card{background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));padding:12px;border-radius:10px;margin-top:12px;border:1px solid rgba(255,255,255,0.03)}
  .meta{color:#9aa4b2;font-size:0.9rem}
  .result{background:rgba(255,255,255,0.02);padding:8px;border-radius:8px;margin-top:8px;max-height:260px;overflow:auto;font-family:ui-monospace,monospace}
  pre{white-space:pre-wrap;margin:0;font-family:ui-monospace,monospace}
  .progressbar{height:10px;background:rgba(255,255,255,0.03);border-radius:8px;overflow:hidden;margin-top:8px}
  .progress{height:100%;background:linear-gradient(90deg,#60a5fa,#3b82f6);width:0%}
  .small{font-size:0.85rem;color:#9aa4b2}
  .status{display:inline-block;padding:6px 8px;border-radius:999px;font-weight:600}
  .status.ok{background:rgba(34,197,94,0.12);color:#22c55e}
  .status.warn{background:rgba(245,158,11,0.08);color:#f59e0b}
  .status.err{background:rgba(239,68,68,0.08);color:#ef4444}
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Monarch Biographies Collector — 5 Countries (Fixed)</h1>
        <div class="lead">This tool fetches kings & queens (biographies) for five countries. Click <strong>Start</strong> and wait — requests are throttled to avoid rate limits.</div>
      </div>
      <div class="controls">
        <button id="startBtn">Start</button>
        <button id="copyBtn" class="ghost">Copy JSON</button>
        <button id="downloadBtn" class="ghost">Download JSON</button>
      </div>
    </header>

    <div class="card">
      <div style="display:flex;justify-content:space-between;align-items:center">
        <div><strong>Progress</strong> <span id="progressText" class="small">Idle</span></div>
        <div><span id="stats" class="small">0 / 5 processed</span></div>
      </div>
      <div class="progressbar"><div id="progress" class="progress"></div></div>
    </div>

    <div id="resultsArea"></div>

    <p class="small" style="margin-top:12px">Notes: heuristics are conservative — they'll try to include people who actually reigned (king/queen/sultan/shah/emir/etc.). If a valid monarch is missed, we can refine the filter.</p>
  </div>

<script>
/* Fixed collector implementation */
const COUNTRIES = ["Afghanistan","Albania","Algeria","Andorra","Angola"];
const SEARCH_QUERIES = [
  "List of monarchs of {c}",
  "Monarchs of {c}",
  "Kings of {c}",
  "List of rulers of {c}",
  "List of heads of state of {c}"
];
const API_BASE = "https://en.wikipedia.org/w/api.php?origin=*";
const THROTTLE = 700;       // ms between significant calls
const MAX_CANDIDATES = 60;  // per country cap
const results = [];         // final array {country, monarchs: [...]}
let processed = 0;

const startBtn = document.getElementById('startBtn');
const copyBtn = document.getElementById('copyBtn');
const downloadBtn = document.getElementById('downloadBtn');
const resultsArea = document.getElementById('resultsArea');
const progressEl = document.getElementById('progress');
const progressText = document.getElementById('progressText');
const statsEl = document.getElementById('stats');

startBtn.onclick = () => run();
copyBtn.onclick = () => copyAll();
downloadBtn.onclick = () => downloadAll();

async function run(){
  startBtn.disabled = true;
  resultsArea.innerHTML = '';
  results.length = 0;
  processed = 0;
  updateProgress();

  for (const country of COUNTRIES) {
    const card = makeCard(country);
    resultsArea.appendChild(card);
    try {
      const monarchs = await processCountry(country, card);
      results.push({ country, monarchs });
      markCardComplete(card, true, monarchs.length);
    } catch (err) {
      console.error('Error processing', country, err);
      results.push({ country, monarchs: [] });
      markCardComplete(card, false, 0, err && err.message);
    }
    processed++;
    updateProgress();
    await sleep(THROTTLE);
  }

  startBtn.disabled = false;
  progressText.textContent = 'Completed';
}

function makeCard(country) {
  const div = document.createElement('div');
  div.className = 'card';
  div.innerHTML = `
    <h3>${escapeHtml(country)} <span class="status" id="status_${idFrom(country)}">queued</span></h3>
    <div class="meta small">Monarchs found: <span id="count_${idFrom(country)}">—</span></div>
    <div id="list_${idFrom(country)}" class="result"><pre id="pre_${idFrom(country)}">Waiting...</pre></div>
  `;
  return div;
}
function markCardComplete(card, ok, count, err) {
  const country = card.querySelector('h3').textContent.split('\n')[0].trim();
  const statusEl = card.querySelector('.status');
  const pre = card.querySelector('pre');
  if (ok) {
    statusEl.className = 'status ok';
    statusEl.textContent = 'ok';
    card.querySelector(`#count_${idFrom(country)}`).textContent = String(count);
  } else {
    statusEl.className = 'status err';
    statusEl.textContent = 'error';
    pre.textContent = 'Error: ' + (err || 'failed');
  }
}

/* --- country-level flow --- */
async function processCountry(country, cardEl) {
  const pre = cardEl.querySelector('pre');
  pre.textContent = 'Searching list pages...';
  // 1) find a likely list page by trying search templates
  let listPage = null;
  for (const tmpl of SEARCH_QUERIES) {
    const q = tmpl.replace('{c}', country);
    try {
      const s = await wikiSearch(q, 5);
      await sleep(250);
      if (!s || !s.length) continue;
      // iterate top hits and test parse HTML content for patterns (lists or 'reign' or 'king')
      for (const hit of s) {
        try {
          const parsed = await wikiParse(hit.title);
          await sleep(200);
          if (parsed && looksLikeMonarchList(parsed.html)) {
            listPage = parsed;
            break;
          }
        } catch(e){
          // ignore
        }
      }
      if (listPage) break;
    } catch(e){
      // ignore and try next template
    }
  }

  if (!listPage) {
    pre.textContent = 'No list page found for ' + country;
    return [];
  }

  pre.textContent = 'Parsing candidate names from list page: ' + listPage.title;
  // 2) extract linked person titles from list page; prefer lists (<ul>/<ol>)
  const candidates = extractPersonTitlesFromListHtml(listPage.html).slice(0, MAX_CANDIDATES);
  if (candidates.length === 0) {
    pre.textContent = 'No candidate person links found on the list page.';
    return [];
  }
  pre.textContent = `Found ${candidates.length} candidate links; verifying each...`;

  // 3) For each candidate, fetch extract+categories and decide if monarch; if yes fetch full bio
  const monarchs = [];
  for (let i=0;i<candidates.length;i++){
    const title = candidates[i];
    pre.textContent = `Checking (${i+1}/${candidates.length}): ${title}`;
    await sleep(THROTTLE);
    try {
      const meta = await wikiGetExtractAndCategories(title);
      if (!meta) continue;
      const judge = isRoyal(meta, country);
      if (!judge) continue;
      // fetch full page HTML and extract cleaned biography
      await sleep(THROTTLE);
      const parsed = await wikiParse(title);
      const bio = parsed ? extractReadableText(parsed.html) : (meta.extract || '');
      const life = extractLife(meta.extract || '');
      monarchs.push({
        name: title,
        url: parsed ? parsed.url : ('https://en.wikipedia.org/wiki/' + encodeURIComponent(title.replace(/ /g,'_'))),
        life: life || null,
        biography: bio || (meta.extract || '')
      });
      // update UI incrementally
      const textNode = document.createElement('div');
      textNode.className = 'line';
      textNode.textContent = `${title}${life ? ' — ' + life : ''}`;
      cardEl.querySelector('.result').appendChild(textNode);
    } catch (e) {
      console.warn('error checking candidate', title, e);
    }
  }

  if (monarchs.length === 0) {
    cardEl.querySelector('pre').textContent = 'No monarchs determined from candidate list.';
  }

  return monarchs;
}

/* --- Wikipedia API helpers --- */
async function wikiSearch(query, limit=5) {
  const url = `${API_BASE}&action=query&list=search&srsearch=${encodeURIComponent(query)}&srlimit=${limit}&format=json`;
  const json = await fetchJson(url);
  return json?.query?.search || [];
}
async function wikiParse(title) {
  const url = `${API_BASE}&action=parse&page=${encodeURIComponent(title)}&prop=text&format=json`;
  const json = await fetchJson(url);
  if (!json?.parse) return null;
  return { html: json.parse.text['*'], title: json.parse.title, url: 'https://en.wikipedia.org/wiki/' + encodeURIComponent(json.parse.title.replace(/ /g,'_')) };
}
async function wikiGetExtractAndCategories(title) {
  const url = `${API_BASE}&action=query&prop=extracts%7Ccategories&exintro&explaintext&titles=${encodeURIComponent(title)}&cllimit=500&format=json`;
  const json = await fetchJson(url);
  const pages = json?.query?.pages;
  if (!pages) return null;
  const pid = Object.keys(pages)[0];
  const p = pages[pid];
  if (!p) return null;
  return { extract: p.extract || '', categories: (p.categories || []).map(c=>c.title) };
}
async function fetchJson(url) {
  const r = await fetch(url);
  if (!r.ok) throw new Error('Network error ' + r.status);
  return r.json();
}

/* --- parsing heuristics --- */
function looksLikeMonarchList(html) {
  if (!html) return false;
  const lower = html.toLowerCase();
  // presence of 'reign' or 'king' or multiple <li> suggests a list of rulers
  if (lower.includes('reign') || lower.includes('king') || lower.includes('queen') || lower.includes('monarch')) return true;
  if (lower.includes('<ul') || lower.includes('<ol')) return true;
  return false;
}

function extractPersonTitlesFromListHtml(html) {
  const doc = new DOMParser().parseFromString(html, 'text/html');
  const content = doc.querySelector('.mw-parser-output') || doc.body;
  if (!content) return [];
  const titles = [];
  // prefer links inside list items
  const lists = content.querySelectorAll('ul,ol');
  for (const ul of lists) {
    const lis = ul.querySelectorAll('li');
    if (lis.length === 0) continue;
    for (const li of lis) {
      const a = li.querySelector('a[title]');
      if (a) {
        const t = a.getAttribute('title');
        if (isValidPersonTitle(t)) titles.push(t);
        // also collect other links in same li
        const others = li.querySelectorAll('a[title]');
        for (const o of others) {
          const tt = o.getAttribute('title');
          if (isValidPersonTitle(tt)) titles.push(tt);
        }
      }
    }
    if (titles.length >= 20) break;
  }
  // fallback: collect links from paragraphs if none found
  if (titles.length === 0) {
    const links = content.querySelectorAll('a[title]');
    for (const a of links) {
      const t = a.getAttribute('title');
      if (isValidPersonTitle(t)) titles.push(t);
      if (titles.length >= 50) break;
    }
  }
  return unique(titles);
}

function isValidPersonTitle(title) {
  if (!title) return false;
  if (title.includes(':')) return false; // skip File:, Category:, etc
  if (!/\s/.test(title)) return false; // likely not a person if single token
  // skip obvious non-persons
  if (/^(List|History|Timeline|Category|Kings and|Dynasty|Government|Politics|Timeline)/i.test(title)) return false;
  return true;
}

function unique(arr) {
  const seen = new Set(); const out = [];
  for (const x of arr) { if (!x) continue; const t = x.trim(); if (!seen.has(t)) { seen.add(t); out.push(t); } }
  return out;
}

/* Decide whether person is monarch */
function isRoyal(meta, country) {
  const extract = (meta.extract || '').toLowerCase();
  const cats = (meta.categories || []).join(' ').toLowerCase();
  const royalWords = /(king|queen|sultan|shah|emir|khan|prince|princess|maharaja|raja|emperor|tsar|czar)/i;
  // If categories contain royal words -> accept
  if (royalWords.test(cats)) return true;
  // If intro extract contains royal words AND words like 'reign' or 'ruled' or 'crowned' -> accept
  if (royalWords.test(extract) && /(reign|reigned|ruled|crowned|ascended|succeeded|was king|was queen|was emperor|was sultan)/i.test(extract)) return true;
  // If intro explicitly says "King of {country}" or "Queen of {country}" -> accept
  if (new RegExp(`(king|queen|sultan|shah|emir|khan|emperor) of ${escapeRegExp(country.toLowerCase())}`, 'i').test(extract)) return true;
  // else: reject (conservative)
  return false;
}

/* extract full readable bio from parse HTML */
function extractReadableText(html) {
  if (!html) return '';
  const doc = new DOMParser().parseFromString(html, 'text/html');
  const content = doc.querySelector('.mw-parser-output') || doc.body;
  if (!content) return '';
  // remove unwanted
  const selectors = ['table', '.infobox', '.navbox', '.vertical-navbox', '.toc', 'sup.reference', 'script', 'style', 'figure'];
  selectors.forEach(s => content.querySelectorAll(s).forEach(n => n.remove()));
  // gather paragraphs and headings
  const parts = [];
  for (const node of content.childNodes) {
    if (node.nodeType !== Node.ELEMENT_NODE) continue;
    const tag = node.tagName.toLowerCase();
    if (tag === 'p') {
      const t = node.textContent.replace(/\[[^\]]*\]/g,'').trim();
      if (t.length > 30) parts.push(t);
    } else if (tag.match(/^h[1-4]$/)) {
      const h = node.textContent.trim();
      if (h) parts.push('\n' + h.toUpperCase() + '\n');
    }
  }
  return parts.join('\n\n').replace(/\n{3,}/g,'\n\n').trim();
}

/* simple life extractor from intro */
function extractLife(intro) {
  if (!intro) return null;
  const m = intro.match(/\((?:born\s*)?(\d{3,4})(?:\s*[–-]\s*(\d{3,4}))?/i);
  if (m) return m[1] + (m[2] ? '–' + m[2] : '');
  const b = intro.match(/born\s+(\d{3,4})/i);
  const d = intro.match(/died\s+(\d{3,4})/i);
  if (b || d) return (b?b[1]:'') + (d?('–'+d[1]):'');
  return null;
}

/* --- Utilities --- */
function idFrom(s){ return s.replace(/[^a-z0-9]/gi,'_'); }
function escapeHtml(s){ return (s||'').replace(/[&<>"']/g, m=>({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'})[m]); }
function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }
function updateProgress(){ const pct = Math.round((processed / COUNTRIES.length) * 100); progressEl.style.width = pct + '%'; progressText.textContent = `${processed} / ${COUNTRIES.length} processed`; statsEl.textContent = `${processed} / ${COUNTRIES.length} processed`; }

/* top-level copy & download */
function copyAll(){
  const json = JSON.stringify(results, null, 2);
  navigator.clipboard.writeText(json).then(()=>alert('JSON copied to clipboard ('+json.length+' characters)'));
}
function downloadAll(){
  const json = JSON.stringify(results, null, 2);
  const blob = new Blob([json], {type:'application/json'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = 'monarchs_5countries.json'; a.click(); URL.revokeObjectURL(url);
}
</script>
</body>
</html>
